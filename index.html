<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>행동 계산기 및 턴 시뮬레이션</title>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f4f7f6;
            color: #333;
            /* 화면 축소 설정 */
            zoom: 0.7; /* 크롬, 엣지, 사파리에서 전체 화면을 70%로 축소 */
            -moz-transform: scale(0.7); /* Firefox를 위한 접두사 */
            -moz-transform-origin: 0 0; /* Firefox에서 좌상단을 기준으로 축소 */
        }
        h1, h2 {
            color: #2c3e50;
        }
        .container {
            display: flex;
            gap: 30px;
            margin-top: 20px;
        }
        .character-manager, .simulation-viewer {
            background-color: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        .character-manager {
            flex: 1;
            min-width: 300px;
        }
        .simulation-viewer {
            flex: 2;
            min-width: 600px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group select { 
            width: calc(100% - 20px);
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1em;
        }
        button {
            padding: 10px 18px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }
        button.primary {
            background-color: #3498db;
            color: white;
        }
        button.primary:hover {
            background-color: #2980b9;
        }
        button.secondary {
            background-color: #e74c3c;
            color: white;
            margin-left: 10px;
        }
        button.secondary:hover {
            background-color: #c0392b;
        }
        #characterList {
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 15px;
        }
        /* 등록된 캐릭터 목록 헤더 스타일 */
        .character-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px; /* 목록과 헤더 사이 간격 */
        }
        .character-list-header h3 {
            margin: 0; /* h3 기본 마진 제거 */
        }
        .character-list-header button {
            padding: 8px 15px;
            font-size: 0.9em;
        }

        .character-item {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
        .character-item span {
            flex: 1;
            min-width: 100px;
            margin-right: 10px;
        }
        .character-item button {
            padding: 8px 12px;
            font-size: 0.9em;
        }
        .simulation-output {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 6px;
            background-color: #fdfdfd;
            min-height: 400px;
            overflow-y: auto;
            max-height: 800px;
        }
        .simulation-event {
            margin-bottom: 15px;
            padding: 10px;
            border-bottom: 1px dashed #eee;
        }
        .simulation-event:last-child {
            border-bottom: none;
        }
        .event-type {
            font-weight: bold;
            color: #27ae60;
        }
        .event-detail {
            margin-top: 5px;
            font-size: 0.95em;
            background-color: #e8f5e9; 
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #c8e6c9;
        }
        .round-marker {
            font-weight: bold;
            color: #8e44ad;
            margin: 20px 0;
            padding: 5px 0;
            border-bottom: 2px solid #8e44ad;
            border-top: 2px solid #8e44ad;
            text-align: center;
            background-color: #f3e5f5;
            border-radius: 4px;
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding-left: 15px; 
            padding-right: 15px; 
            flex-wrap: wrap; /* 내용이 넘칠 경우 다음 줄로 넘어가도록 */
        }
        /* 라운드 마커 내 버튼과 폼을 위한 스타일 */
        .round-marker button {
            padding: 5px 10px;
            font-size: 0.8em;
            margin-left: 10px; 
        }
        .round-marker .round-event-form-wrapper { /* 폼을 감싸는 div */
            width: 100%; /* 폼이 라운드 마커 전체 너비를 차지하도록 */
            padding-top: 10px; /* 버튼과 폼 사이에 간격 추가 */
            display: flex; /* 내부 요소들을 정렬하기 위해 */
            justify-content: center; /* 폼을 가운데 정렬 */
        }

        .character-turn {
            font-weight: bold;
            color: #3498db;
            margin-top: 10px;
            margin-bottom: 5px;
            background-color: #e0f2f7;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #b3e5fc;
        }
        /* 이벤트 폼의 기본 상태는 숨김 */
        .event-form {
            background-color: #f0f8ff;
            border: 1px solid #d0e0ff;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px; /* 폼이 뜨는 위치에 따라 조절 */
            display: none; /* 기본적으로 모든 폼 숨김 */
            width: 90%; /* 폼의 너비 조절 */
            max-width: 500px; /* 폼의 최대 너비 제한 */
        }
        /* active 클래스가 있을 때만 보이도록 */
        .event-form.active {
            display: block;
        }
        .event-form .form-group {
            margin-bottom: 10px;
        }
        .event-form input[type="checkbox"] {
            margin-right: 5px;
            transform: scale(1.2);
        }
        .event-form label {
            display: inline-block; 
            margin-bottom: 0;
        }
        /* 라운드 표시 On/Off 버튼 스타일 */
        .round-toggle-container {
            display: inline-flex;
            align-items: center;
            margin-left: 15px;
            gap: 8px;
        }
        .round-toggle-btn {
            padding: 5px 10px;
            font-size: 0.9em;
            background-color: #6c757d;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .round-toggle-btn.on {
            background-color: #28a745; 
        }
        .round-toggle-btn.off {
            background-color: #dc3545; 
        }

        /* 데이터 전송 섹션 스타일 */
        .data-transfer-section {
            margin-top: 30px;
            padding: 20px;
            border: 1px dashed #ccc;
            border-radius: 8px;
            background-color: #fcfcfc;
            text-align: center;
        }
        .data-transfer-section button {
            margin: 5px 10px;
        }
        .data-transfer-section p {
            margin-bottom: 15px;
        }
    </style>
</head>
<body>

    <h1>행동 계산기</h1>

    <div class="container">
        <div class="character-manager">
            <h2>캐릭터 관리</h2>
            <div class="form-group">
                <label for="charName">이름:</label>
                <input type="text" id="charName" placeholder="캐릭터 이름" required>
            </div>
            <div class="form-group">
                <label for="baseSpeed">기본 속도:</label>
                <input type="number" id="baseSpeed" value="100" min="1" required>
            </div>
            <div class="form-group">
                <label for="initialCurrentSpeed">현재 속도:</label> 
                <input type="number" id="initialCurrentSpeed" value="100" min="1" required>
            </div>
            <button class="primary" onclick="addOrUpdateCharacter()">캐릭터 추가</button>
            <button class="secondary" onclick="clearCharacterForm()">초기화</button>

            <div id="characterList">
                <div class="character-list-header">
                    <h3>등록된 캐릭터</h3>
                    <button class="secondary" onclick="clearAllCharacters()">전체 초기화</button>
                </div>
                </div>
        </div>

        <div class="simulation-viewer">
            <h2>
                턴 시뮬레이션
                <span class="round-toggle-container">
                    <span id="roundToggleText">라운드 표시: ON</span>
                    <button id="roundToggleButton" class="round-toggle-btn on" onclick="toggleRoundMarkers()">ON/OFF</button>
                </span>
            </h2>
            <button class="primary" onclick="runSimulation()">시뮬레이션 실행</button>
            <button class="secondary" onclick="resetSimulationState()">시뮬레이션 초기화</button>
            <div id="simulationOutput" class="simulation-output">
            </div>

            <div class="data-transfer-section">
                <h3>데이터 공유</h3>
                <p>현재 캐릭터 및 라운드 이벤트 데이터를 파일로 저장하거나 URL로 공유할 수 있습니다.</p>
                <button class="primary" onclick="saveDataAsFile()">데이터 파일로 저장</button>
                <input type="file" id="loadFileInput" accept=".json" style="display: none;" onchange="loadDataFromFile(event)">
                <button class="primary" onclick="document.getElementById('loadFileInput').click()">데이터 파일 불러오기</button>
                <span id="loadStatus" style="margin-left: 10px; color: #888; font-size: 0.9em;"></span>
                <br><br>
                <button class="primary" onclick="updateShareableUrl()">URL로 데이터 공유</button>
                <p style="font-size: 0.9em; color: #666; margin-top: 10px;">URL이 주소창에 나타나면, 해당 URL을 복사하여 공유할 수 있습니다.</p>
            </div>

        </div>
    </div>

    <script>
        let characters = JSON.parse(localStorage.getItem('characters')) || [];
        let editingCharId = null; 

        // currentSimState는 시뮬레이션 런타임에만 사용되는 임시 데이터입니다.
        let currentSimState = []; 
        let showRoundMarkers = JSON.parse(localStorage.getItem('showRoundMarkers')) !== null ? JSON.parse(localStorage.getItem('showRoundMarkers')) : true;

        // 모든 라운드 및 턴 이벤트를 저장하는 새로운 전역 배열
        let futureEvents = JSON.parse(localStorage.getItem('futureEvents')) || []; 

        const BUFF_DURATION_OPTIONS = [
            { value: 0, label: "지속 시간 없음 (영구)" }, 
            { value: 1, label: "1턴" },
            { value: 2, label: "2턴" },
            { value: 3, label: "3턴" },
            { value: 4, label: "4턴" },
            { value: 5, label: "5턴" }
        ];

        // --- 데이터 저장/불러오기 기능 (기존과 동일) ---

        function saveDataAsFile() {
            const dataToSave = {
                characters: characters,
                futureEvents: futureEvents
            };
            const jsonString = JSON.stringify(dataToSave, null, 2); 

            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `speed_calculator_data_${new Date().toISOString().slice(0, 10)}.json`; 
            document.body.appendChild(a); 
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert('데이터 파일이 성공적으로 저장되었습니다.');
        }

        function loadDataFromFile(event) {
            const file = event.target.files[0];
            if (!file) {
                document.getElementById('loadStatus').textContent = '파일을 선택하지 않았습니다.';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);

                    if (loadedData.characters && Array.isArray(loadedData.characters) &&
                        loadedData.futureEvents && Array.isArray(loadedData.futureEvents)) {
                        
                        characters = loadedData.characters;
                        futureEvents = loadedData.futureEvents;

                        localStorage.setItem('characters', JSON.stringify(characters));
                        localStorage.setItem('futureEvents', JSON.stringify(futureEvents));

                        renderCharacterList(); 
                        runSimulation();      
                        document.getElementById('loadStatus').textContent = '데이터를 성공적으로 불러왔습니다.';
                        alert('데이터를 성공적으로 불러왔습니다.');

                    } else {
                        throw new Error('올바른 데이터 형식이 아닙니다.');
                    }
                } catch (error) {
                    console.error('데이터 불러오기 오류:', error);
                    document.getElementById('loadStatus').textContent = `데이터 불러오기 실패: ${error.message}`;
                    alert(`데이터 불러오기 실패: ${error.message}\n(올바른 .json 파일인지 확인해주세요.)`);
                } finally {
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        }

        // --- URL을 통한 데이터 공유 기능 (pako.js 및 history.pushState 적용) ---

        // 문자열을 UTF-8 바이트 배열로 변환 (한글 포함 가능)
        function stringToUint8Array(str) {
            return new TextEncoder().encode(str);
        }

        // UTF-8 바이트 배열을 문자열로 변환 (한글 포함 가능)
        function uint8ArrayToString(arr) {
            return new TextDecoder().decode(arr);
        }

        // Base64 URL 안전 인코딩: 일반 Base64에서 URL에 문제를 일으킬 수 있는 문자 (+, /)를 변경하고 패딩(=)을 제거
        function base64UrlEncode(bytes) {
            let binary = '';
            for (let i = 0; i < bytes.length; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary)
                .replace(/\+/g, '-') // +를 -로 대체
                .replace(/\//g, '_') // /를 _로 대체
                .replace(/=+$/, ''); // = 패딩 제거
        }

        // Base64 URL 안전 디코딩: 인코딩된 문자열을 원래 Base64로 복원하고 디코딩
        function base64UrlDecode(str) {
            str = str.replace(/-/g, '+').replace(/_/g, '/'); // 변경된 문자를 다시 복원
            while (str.length % 4) { // 제거된 = 패딩 다시 추가
                str += '=';
            }
            const binary = atob(str);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        }

        // 현재 데이터를 압축하고 Base64로 인코딩하여 URL에 반영하고 클립보드에 복사
        async function updateShareableUrl() { // 비동기 함수로 변경
            const dataToShare = {
                characters: characters,
                futureEvents: futureEvents
            };
            const jsonString = JSON.stringify(dataToShare);

            try {
                // 1. JSON 문자열을 UTF-8 바이트 배열로 변환 (한글 처리)
                const utf8Bytes = stringToUint8Array(jsonString);
                // 2. pako를 사용하여 압축 (deflate): 최고 압축 레벨 (9) 사용
                const compressedBytes = pako.deflate(utf8Bytes, { level: 9 });
                // 3. 압축된 바이트 배열을 Base64 URL 안전 문자열로 인코딩
                const encodedData = base64UrlEncode(compressedBytes);

                const baseUrl = window.location.origin + window.location.pathname;
                // 'data' 쿼리 파라미터에 인코딩된 데이터 추가
                const shareUrl = `${baseUrl}?data=${encodedData}`;

                // window.history.pushState를 사용하여 URL을 변경하지만 페이지를 새로고침하지 않음
                window.history.pushState({}, '', shareUrl); 

                const currentLength = shareUrl.length;
                let alertMessage = '';

                if (currentLength > 2000) { 
                    alertMessage = '경고: 생성된 URL이 매우 깁니다! (길이: ' + currentLength + ')\n일부 브라우저나 시스템에서 문제가 발생할 수 있습니다.';
                } else {
                    alertMessage = 'URL이 주소창에 반영되었습니다! 이제 클립보드에 복사되었습니다. (길이: ' + currentLength + ')';
                }

                // 클립보드에 URL 복사
                await navigator.clipboard.writeText(shareUrl);
                alert(alertMessage);

            } catch (error) {
                console.error('URL 생성 또는 복사 중 오류:', error);
                alert('URL 생성 또는 복사 중 오류가 발생했습니다: ' + error.message);
            }
        }

        // 페이지 로드 시 URL에서 데이터 불러오기
        function loadDataFromUrl() {
            const params = new URLSearchParams(window.location.search);
            const encodedData = params.get('data');

            if (encodedData) {
                try {
                    // 1. Base64 URL 안전 디코딩
                    const compressedBytes = base64UrlDecode(encodedData);
                    // 2. pako를 사용하여 압축 해제 (inflate)
                    const utf8Bytes = pako.inflate(compressedBytes);
                    // 3. UTF-8 바이트 배열을 문자열로 변환
                    const decodedData = uint8ArrayToString(utf8Bytes);
                    // 4. JSON 파싱
                    const loadedData = JSON.parse(decodedData);

                    if (loadedData.characters && Array.isArray(loadedData.characters) &&
                        loadedData.futureEvents && Array.isArray(loadedData.futureEvents)) {
                        
                        characters = loadedData.characters;
                        futureEvents = loadedData.futureEvents;

                        localStorage.setItem('characters', JSON.stringify(characters));
                        localStorage.setItem('futureEvents', JSON.stringify(futureEvents));

                        renderCharacterList();
                        // runSimulation()은 이 함수가 완료된 후 window.onload에서 호출됩니다.
                        alert('URL에서 데이터를 성공적으로 불러왔습니다!');
                        // URL에서 데이터를 로드한 후에는 쿼리 파라미터를 제거하여 깔끔하게 유지할 수 있습니다.
                        // window.history.replaceState({}, '', window.location.origin + window.location.pathname);
                    } else {
                        throw new Error('URL 데이터 형식이 올바르지 않습니다.');
                    }
                } catch (error) {
                    console.error('URL 데이터 불러오기 오류:', error);
                    alert(`URL 데이터 불러오기 실패: ${error.message}\n(손상된 URL이거나 올바른 형식이 아닙니다.)`);
                }
            }
        }

        // --- 기존 시뮬레이션 및 UI 로직 (이 부분은 이전 코드와 동일합니다) ---

        function toggleRoundMarkers() {
            showRoundMarkers = !showRoundMarkers; 
            localStorage.setItem('showRoundMarkers', JSON.stringify(showRoundMarkers)); 
            updateRoundToggleButtonUI(); 
            runSimulation(); 
        }

        function updateRoundToggleButtonUI() {
            const button = document.getElementById('roundToggleButton');
            const text = document.getElementById('roundToggleText');
            if (showRoundMarkers) {
                text.textContent = '라운드 표시: ON';
                button.classList.remove('off');
                button.classList.add('on');
            } else {
                text.textContent = '라운드 표시: OFF';
                button.classList.remove('on');
                button.classList.add('off');
            }
        }

        function renderCharacterList() {
            const listDiv = document.getElementById('characterList');
            const headerDiv = `
                <div class="character-list-header">
                    <h3>등록된 캐릭터</h3>
                    <button class="secondary" onclick="clearAllCharacters()">전체 초기화</button>
                </div>
            `;
            listDiv.innerHTML = headerDiv; 

            if (characters.length === 0) {
                listDiv.innerHTML += '<p>등록된 캐릭터가 없습니다.</p>';
                return;
            }
            characters.forEach(char => {
                const charItem = document.createElement('div');
                charItem.className = 'character-item';
                charItem.innerHTML = `
                    <span>이름: ${char.name}</span>
                    <span>기본 속도: ${char.baseSpeed}</span>
                    <span>현재 속도: ${char.initialCurrentSpeed}</span> 
                    <div>
                        <button class="primary" onclick="editCharacter('${char.id}')">수정</button>
                        <button class="secondary" onclick="deleteCharacter('${char.id}')">삭제</button>
                    </div>
                `;
                listDiv.appendChild(charItem);
            });
        }

        function clearAllCharacters() {
            if (confirm('모든 등록된 캐릭터와 이벤트를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
                characters = []; 
                localStorage.setItem('characters', JSON.stringify(characters)); 
                futureEvents = []; // futureEvents 초기화
                localStorage.setItem('futureEvents', JSON.stringify(futureEvents));
                renderCharacterList(); 
                clearCharacterForm(); 
                runSimulation(); 
                alert('모든 캐릭터와 라운드 이벤트가 초기화되었습니다.');

                const baseUrl = window.location.origin + window.location.pathname;
                window.history.replaceState({}, '', baseUrl); 
            }
        }

        function addOrUpdateCharacter() {
            const name = document.getElementById('charName').value;
            const baseSpeed = parseInt(document.getElementById('baseSpeed').value);
            const initialCurrentSpeed = parseInt(document.getElementById('initialCurrentSpeed').value); 

            if (!name || isNaN(baseSpeed) || baseSpeed <= 0 || isNaN(initialCurrentSpeed) || initialCurrentSpeed <= 0) {
                alert('모든 필드를 올바르게 입력해주세요.');
                return;
            }

            if (editingCharId) {
                const charIndex = characters.findIndex(char => char.id === editingCharId);
                if (charIndex !== -1) {
                    characters[charIndex] = { 
                        ...characters[charIndex], 
                        name, 
                        baseSpeed: baseSpeed, 
                        initialCurrentSpeed: initialCurrentSpeed 
                    };
                }
                editingCharId = null;
                document.querySelector('button.primary').textContent = '캐릭터 추가';
            } else {
                const newChar = {
                    id: Date.now().toString(), 
                    name,
                    baseSpeed: baseSpeed, 
                    initialCurrentSpeed: initialCurrentSpeed, 
                    currentGauge: 0, 
                };
                characters.push(newChar);
            }
            localStorage.setItem('characters', JSON.stringify(characters));
            renderCharacterList();
            runSimulation(); 
        }

        function editCharacter(id) {
            const char = characters.find(c => c.id === id);
            if (char) {
                document.getElementById('charName').value = char.name;
                document.getElementById('baseSpeed').value = char.baseSpeed;
                document.getElementById('initialCurrentSpeed').value = char.initialCurrentSpeed; 
                editingCharId = char.id;
                document.querySelector('button.primary').textContent = '캐릭터 수정';
            }
        }

        function deleteCharacter(id) {
            if (confirm('이 캐릭터를 삭제하시겠습니까?')) {
                characters = characters.filter(char => char.id !== id);
                // 해당 캐릭터에 대한 futureEvents도 삭제
                futureEvents = futureEvents.filter(event => event.targetId !== id && event.actingCharId !== id);
                localStorage.setItem('characters', JSON.stringify(characters));
                localStorage.setItem('futureEvents', JSON.stringify(futureEvents));
                renderCharacterList();
                clearCharacterForm();
                runSimulation(); 
            }
        }

        function resetSimulationState() {
            if (confirm('모든 캐릭터의 시뮬레이션 상태 (게이지)와 저장된 모든 이벤트를 초기화하시겠습니까?')) {
                characters.forEach(char => {
                    char.currentGauge = 0; // 게이지는 초기화
                });
                futureEvents = []; // 모든 이벤트 초기화
                localStorage.setItem('characters', JSON.stringify(characters));
                localStorage.setItem('futureEvents', JSON.stringify(futureEvents)); 
                runSimulation(); 
            }
        }

        function clearCharacterForm() {
            document.getElementById('charName').value = '';
            document.getElementById('baseSpeed').value = '100';
            document.getElementById('initialCurrentSpeed').value = '100'; 
            editingCharId = null;
            document.querySelector('button.primary').textContent = '캐릭터 추가';
        }

        function calculateAV(speed) {
            if (speed <= 0) return Infinity; 
            return 10000 / speed;
        }

        function getRound(av) {
            if (av >= 0 && av <= 150) {
                return 0;
            } else if (av > 150 && av <= 250) {
                return 1;
            } else if (av > 250 && av <= 350) {
                return 2;
            } else if (av > 350 && av <= 450) {
                return 3;
            } else if (av > 450 && av <= 550) {
                return 4;
            } else if (av > 550 && av <= 650) {
                return 5;
            }
            return Math.floor((av - 150.01) / 100) + 1; 
        }

        function runSimulation() {
            const outputDiv = document.getElementById('simulationOutput');
            outputDiv.innerHTML = ''; 

            if (characters.length === 0) {
                outputDiv.innerHTML = '<p>시뮬레이션을 실행하려면 캐릭터를 추가해주세요.</p>';
                return;
            }

            // 모든 이벤트 폼 숨기기 및 동적으로 추가된 라운드 이벤트 폼 제거
            document.querySelectorAll('.event-form').forEach(form => {
                form.classList.remove('active');
                if (form.parentNode && form.parentNode.classList.contains('round-event-form-wrapper')) {
                    form.parentNode.remove();
                }
            });

            // currentSimState는 characters의 현재 상태를 깊은 복사하여 시뮬레이션에 사용합니다.
            // 버프, 이력은 currentSimState에서만 관리되며, futureEvents를 통해 주입됩니다.
            currentSimState = characters.map(char => {
                const initialSpeed = typeof char.initialCurrentSpeed === 'number' && !isNaN(char.initialCurrentSpeed) && char.initialCurrentSpeed > 0 
                                     ? char.initialCurrentSpeed 
                                     : (typeof char.baseSpeed === 'number' && !isNaN(char.baseSpeed) && char.baseSpeed > 0 ? char.baseSpeed : 100);

                const baseSpeed = typeof char.baseSpeed === 'number' && !isNaN(char.baseSpeed) && char.baseSpeed > 0 
                                  ? char.baseSpeed : 100;
                
                return {
                    id: char.id,
                    name: char.name,
                    baseSpeed: baseSpeed, 
                    initialCurrentSpeed: initialSpeed, 
                    currentSpeed: initialSpeed, 
                    currentGauge: char.currentGauge || 0, // 저장된 게이지를 가져옵니다. (없으면 0)
                    buffs: [], // 시뮬레이션 시작 시 버프는 초기화
                    pendingBuffs: [] // 다음 턴에 적용될 버프를 임시 저장
                };
            });
            
            let currentGlobalAV = 0;
            let turnCount = 0;
            const MAX_TURNS = 50; 

            // 0 라운드 시작 마커 및 이벤트 적용
            if (showRoundMarkers) {
                outputDiv.innerHTML += `
                    <div class="round-marker" id="round-marker-0">
                        <span class="marker-text">0 라운드 시작</span>
                        <button class="primary" onclick="showRoundEventForm(event, 0)">라운드 이벤트 추가</button>
                    </div>
                `;
            }
            let currentRound = 0;

            applyFutureRoundEventsToSimState(0, outputDiv); // 0 라운드 futureEvents 적용

            while (turnCount < MAX_TURNS) {
                turnCount++;

                // 턴 시작 시점에 pendingBuffs를 실제 buffs로 이동하고, 지속 시간 감소
                currentSimState.forEach(char => {
                    // pendingBuffs를 현재 buffs에 추가
                    char.pendingBuffs.forEach(pb => char.buffs.push(pb));
                    char.pendingBuffs = []; // pendingBuffs 초기화

                    // 버프 지속 시간 감소 (turnsRemaining이 0이 되면 필터링하여 제거)
                    char.buffs = char.buffs.map(buff => {
                        if (buff.duration > 0 && buff.turnsRemaining > 0) { 
                            buff.turnsRemaining--;
                        }
                        return buff;
                    }).filter(buff => buff.turnsRemaining > 0 || buff.duration === 0); // duration이 0이면 영구 버프
                });

                // 현재 턴의 속도를 계산 (이전 턴까지 적용된 버프만 반영)
                updateAllCharactersCurrentSpeed(currentSimState); 

                let nextChar = null;
                let minTimeNeeded = Infinity; // 다음 턴을 잡기 위해 필요한 최소 AV
                currentSimState.forEach(char => {
                    // 속도가 0 이하인 경우 턴을 잡을 수 없으므로 최소 1로 설정
                    if (char.currentSpeed <= 0) char.currentSpeed = 1; 

                    const remainingGauge = 10000 - char.currentGauge;
                    const actualRemainingGauge = Math.max(0, remainingGauge); // 게이지가 이미 10000을 넘으면 0으로 간주
                    const timeNeeded = actualRemainingGauge / char.currentSpeed; 
                    
                    if (timeNeeded < minTimeNeeded) {
                        minTimeNeeded = timeNeeded;
                        nextChar = char;
                    } else if (timeNeeded === minTimeNeeded) { 
                        // 시간(AV)이 같을 경우, 속도가 빠른 캐릭터가 먼저 턴을 잡음
                        if (nextChar && char.currentSpeed > nextChar.currentSpeed) {
                            nextChar = char;
                        } else if (nextChar && char.currentSpeed === nextChar.currentSpeed) {
                            // 속도도 같을 경우, id가 작은 캐릭터가 먼저 (추가된 순서)
                            if (parseInt(char.id) < parseInt(nextChar.id)) { 
                                nextChar = char;
                            }
                        }
                    }
                });

                if (!nextChar || minTimeNeeded === Infinity || minTimeNeeded < 0) {
                    outputDiv.innerHTML += `<div class="simulation-event">더 이상 턴을 잡을 캐릭터가 없거나 시뮬레이션이 불안정합니다. (현재 AV: ${currentGlobalAV.toFixed(2)})</div>`;
                    break; // 시뮬레이션 종료
                }

                currentGlobalAV += minTimeNeeded; // 전체 AV 업데이트

                // 라운드 변경 감지 및 마커 출력
                const newRound = getRound(currentGlobalAV);
                if (newRound > currentRound) {
                    if (showRoundMarkers) {
                        outputDiv.innerHTML += `<div class="round-marker"><span class="marker-text">${currentRound} 라운드 끝</span></div>`; 
                        for (let r = currentRound + 1; r <= newRound; r++) {
                            outputDiv.innerHTML += `
                                <div class="round-marker" id="round-marker-${r}">
                                    <span class="marker-text">${r} 라운드 시작</span>
                                    <button class="primary" onclick="showRoundEventForm(event, ${r})">라운드 이벤트 추가</button>
                                </div>
                            `;
                            // 새로운 라운드에 해당하는 futureEvents를 찾아서 적용합니다.
                            applyFutureRoundEventsToSimState(r, outputDiv); 
                        }
                    }
                    currentRound = newRound;
                }

                // 다음 턴을 잡은 캐릭터를 제외한 모든 캐릭터의 게이지 증가
                currentSimState.forEach(char => {
                    if (char.id !== nextChar.id) { 
                        char.currentGauge += minTimeNeeded * char.currentSpeed; 
                        // 게이지가 10000을 초과하지 않도록 보정
                        if (char.currentGauge > 10000) {
                            char.currentGauge = 10000; 
                        }
                    }
                });
                nextChar.currentGauge = 0; // 턴을 잡은 캐릭터는 게이지 초기화

                // 턴 기록 출력
                const turnId = `turn-${nextChar.id}-${turnCount}`; // 각 턴 이벤트 폼의 고유 ID를 위한 조합
                outputDiv.innerHTML += `
                    <div class="simulation-event" id="sim-event-${turnId}">
                        <div class="character-turn">[${turnCount}] ${nextChar.name} (${nextChar.currentSpeed} 속도) ${currentGlobalAV.toFixed(2)}av</div>
                        <button class="primary" onclick="showTurnEventForm('form-${turnId}', '${nextChar.id}', ${currentGlobalAV.toFixed(2)}, ${turnCount})">이벤트 추가</button>
                        <div id="form-${turnId}" class="event-form">
                            <div class="form-group">
                                <label>대상:</label>
                                <select id="target-${turnId}">
                                    <option value="all">모든 캐릭터</option>
                                    ${characters.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                                </select>
                            </div>
                            <div class="form-group">
                                <label>이벤트 종류:</label>
                                <select id="eventType-${turnId}" onchange="toggleBuffDuration('form-${turnId}')">
                                    <option value="gauge">행동 게이지 증가 (%)</option>
                                    <option value="speed">속도 변동 (%, 고정 속도)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="value-${turnId}">값:</label>
                                <input type="text" id="value-${turnId}" placeholder="값 (예: 20, 10%)" required> 
                            </div>
                            <div class="form-group" id="buffDurationGroup-${turnId}" style="display:none;">
                                <label for="buffDuration-${turnId}">버프 지속 시간 (턴):</label>
                                <select id="buffDuration-${turnId}">
                                    ${BUFF_DURATION_OPTIONS.map(opt => `<option value="${opt.value}">${opt.label}</option>`).join('')}
                                </select>
                            </div>
                            <div class="form-group">
                                <input type="checkbox" id="isHold-${turnId}">
                                <label for="isHold-${turnId}">홀드 상태에서 발동</label>
                            </div>
                            <button class="primary" onclick="applyTurnEvent('${turnId}', '${nextChar.id}', ${currentGlobalAV.toFixed(2)}, ${turnCount})">적용</button>
                            <button class="secondary" onclick="document.getElementById('form-${turnId}').classList.remove('active');">닫기</button>
                        </div>
                    </div>
                `;

                // **현재 턴에 해당하는 futureEvents를 찾아서 currentSimState에 적용합니다.**
                // 홀드 이벤트 먼저, 그 다음 턴 종료 후 이벤트.
                const eventsForThisTurn = futureEvents.filter(e => e.type === 'turn' && e.turnNum === turnCount && e.actingCharId === nextChar.id);

                eventsForThisTurn.filter(e => e.isHold).forEach(event => { // 홀드 이벤트
                    applyFutureEventToSimState(event, outputDiv, turnId);
                });

                eventsForThisTurn.filter(e => !e.isHold).forEach(event => { // 턴 종료 후 이벤트
                    applyFutureEventToSimState(event, outputDiv, turnId);
                });
            }
            if (showRoundMarkers) {
                outputDiv.innerHTML += `<div class="round-marker"><span class="marker-text">${currentRound} 라운드 끝</span></div>`; 
            }
        }

        // 라운드 이벤트 폼 보이기/숨기기
        function showRoundEventForm(event, roundNum) {
            // 다른 열려있는 모든 폼 닫기
            document.querySelectorAll('.event-form').forEach(form => {
                form.classList.remove('active');
                if (form.parentNode && form.parentNode.classList.contains('round-event-form-wrapper')) {
                    form.parentNode.remove();
                }
            });

            const roundMarkerDiv = event.currentTarget.closest('.round-marker');
            if (!roundMarkerDiv) return;

            // 이미 라운드 이벤트 폼이 있다면 재사용, 없으면 새로 생성
            let form = document.getElementById('roundEventFormContainer');
            if (!form) {
                form = document.createElement('div');
                form.id = 'roundEventFormContainer';
                form.classList.add('event-form');
                form.innerHTML = `
                    <h3>라운드 이벤트 추가</h3>
                    <input type="hidden" id="currentRoundForEvent">
                    <div class="form-group">
                        <label>대상:</label>
                        <select id="roundEventTarget">
                        </select>
                    </div>
                    <div class="form-group">
                        <label>이벤트 종류:</label>
                        <select id="roundEventType" onchange="toggleBuffDuration('roundEventFormContainer')">
                            <option value="gauge">행동 게이지 증가 (%)</option>
                            <option value="speed">속도 변동 (%, 고정 속도)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="roundEventValue">값:</label>
                        <input type="text" id="roundEventValue" placeholder="값 (예: 20, 10%)" required> 
                    </div>
                    <div class="form-group" id="buffDurationGroup-roundEventFormContainer" style="display:none;">
                        <label for="roundEventBuffDuration">버프 지속 시간 (턴):</label>
                        <select id="roundEventBuffDuration">
                        </select>
                    </div>
                    <button class="primary" onclick="applyRoundEvent()">적용</button>
                    <button class="secondary" onclick="document.getElementById('roundEventFormContainer').classList.remove('active');
                                                 if(document.getElementById('roundEventFormContainer').parentNode && document.getElementById('roundEventFormContainer').parentNode.classList.contains('round-event-form-wrapper')) {
                                                     document.getElementById('roundEventFormContainer').parentNode.remove();
                                                 }
                                                 ">닫기</button>
                `;
            }

            // 라운드 마커 아래에 폼을 감싸는 div 추가 (폼이 라운드 마커 안에 표시되도록)
            let formWrapper = roundMarkerDiv.querySelector('.round-event-form-wrapper');
            if (!formWrapper) {
                formWrapper = document.createElement('div');
                formWrapper.classList.add('round-event-form-wrapper');
                roundMarkerDiv.appendChild(formWrapper);
            }
            formWrapper.appendChild(form); 

            form.classList.add('active'); // 폼 활성화
            document.getElementById('currentRoundForEvent').value = roundNum; // 라운드 넘버 설정

            const targetSelect = document.getElementById('roundEventTarget');
            targetSelect.innerHTML = `<option value="all">모든 캐릭터</option>` +
                characters.map(c => `<option value="${c.id}">${c.name}</option>`).join(''); // 캐릭터 목록 옵션 채우기
            
            // 폼 필드 초기화
            document.getElementById('roundEventType').value = 'gauge';
            document.getElementById('roundEventValue').value = '';
            
            const buffDurationSelect = document.getElementById('roundEventBuffDuration');
            buffDurationSelect.innerHTML = BUFF_DURATION_OPTIONS.map(opt => `<option value="${opt.value}">${opt.label}</option>`).join('');
            buffDurationSelect.value = '0'; // 기본값 설정

            toggleBuffDuration('roundEventFormContainer'); // 버프 지속 시간 필드 표시/숨김
        }

        // 라운드 이벤트 적용 (futureEvents 배열에 저장)
        function applyRoundEvent() {
            const roundNum = parseInt(document.getElementById('currentRoundForEvent').value);
            const targetId = document.getElementById('roundEventTarget').value;
            const eventType = document.getElementById('roundEventType').value;
            let valueInput = document.getElementById('roundEventValue').value;
            const buffDuration = parseInt(document.getElementById('roundEventBuffDuration').value);

            let value;
            let valueType = '';

            if (valueInput.endsWith('%')) {
                valueType = '%';
                value = parseFloat(valueInput.slice(0, -1));
            } else {
                valueType = 'fixed';
                value = parseFloat(valueInput);
            }

            if (isNaN(value)) {
                alert('값을 올바르게 입력해주세요 (예: 20 또는 10%).');
                return;
            }

            const targets = targetId === 'all' ? characters : characters.filter(c => c.id === targetId);

            targets.forEach(targetChar => {
                let eventDescription = ``;
                let eventData = {
                    type: 'round', // 이벤트 타입 명시
                    roundNum: roundNum, 
                    targetId: targetChar.id,
                    eventType: eventType, 
                    value: value,
                    valueType: valueType,
                    buffDuration: buffDuration,
                };

                if (eventType === 'gauge') {
                    eventDescription = `라운드 ${roundNum} 시작: ${targetChar.name}에게 행동 게이지 ${value}% 증가`;
                } else if (eventType === 'speed') {
                    eventDescription = `라운드 ${roundNum} 시작: ${targetChar.name}에게 속도 ${value}${valueType} 변동 (${buffDuration > 0 ? buffDuration + '턴 지속' : '영구'})`;
                }
                eventData.description = eventDescription;
                futureEvents.push(eventData); // futureEvents 배열에 이벤트 추가
            });

            localStorage.setItem('futureEvents', JSON.stringify(futureEvents)); // 로컬 스토리지에 저장
            // 폼 숨기고 부모 래퍼 제거
            const form = document.getElementById('roundEventFormContainer');
            if (form) {
                form.classList.remove('active');
                if (form.parentNode && form.parentNode.classList.contains('round-event-form-wrapper')) {
                    form.parentNode.remove();
                }
            }
            runSimulation(); // 변경 사항 반영을 위해 시뮬레이션 다시 실행 (0턴부터)
        }

        // 새로운 함수: futureEvents 중 라운드 이벤트를 currentSimState에 적용하고 UI에 표시
        function applyFutureRoundEventsToSimState(currentRound, outputDiv) {
            const eventsForThisRound = futureEvents.filter(e => e.type === 'round' && e.roundNum === currentRound);
            if (eventsForThisRound.length > 0) {
                outputDiv.innerHTML += `<div class="event-detail" style="background-color: #ffe0b2; border: 1px solid #ffcc80;">라운드 ${currentRound} 시작 이벤트:</div>`;
                eventsForThisRound.forEach(event => {
                    applyFutureEventToSimState(event, outputDiv, null); // 라운드 이벤트는 uiTurnId가 없음
                });
            }
        }

        // 새로운 함수: futureEvent 하나를 currentSimState에 적용하고 UI에 표시
        function applyFutureEventToSimState(event, outputDiv, uiTurnId) {
            const eventOutput = document.createElement('div');
            eventOutput.innerHTML = event.description;
            eventOutput.classList.add('event-detail');

            if (event.type === 'round') {
                // 라운드 이벤트는 라운드 마커 아래에 직접 추가
                eventOutput.style.backgroundColor = '#fff3e0'; 
                eventOutput.style.borderColor = '#ffcc80'; 
                outputDiv.appendChild(eventOutput);
            } else if (event.type === 'turn' && uiTurnId) {
                // 턴 이벤트는 해당 턴의 simulation-event div 안에 추가
                const eventDiv = document.getElementById(`sim-event-${uiTurnId}`);
                if (eventDiv) {
                    eventDiv.appendChild(eventOutput);
                } else {
                    // 혹시 못 찾으면 그냥 outputDiv에 추가 (예외 처리)
                    outputDiv.appendChild(eventOutput); 
                }
            } else { // 기타 (예외 처리)
                outputDiv.appendChild(eventOutput);
            }
            
            // currentSimState의 해당 캐릭터에 이벤트 효과 적용
            const targetSimChars = event.targetId === 'all' ? currentSimState : currentSimState.filter(c => c.id === event.targetId);
            targetSimChars.forEach(simChar => {
                if (event.eventType === 'gauge') { // eventType 필드 사용
                    const gaugeToAdd = 10000 * (event.value / 100);
                    simChar.currentGauge = Math.min(10000, simChar.currentGauge + gaugeToAdd);
                } else if (event.eventType === 'speed') { // eventType 필드 사용
                    // 속도 버프는 pendingBuffs에 추가하여 다음 턴부터 반영되도록 합니다.
                    // (라운드 이벤트의 경우 바로 적용해도 되지만, 일관성을 위해 pendingBuffs 사용)
                    simChar.pendingBuffs = simChar.pendingBuffs || [];
                    // 중복 속도 버프 방지 (같은 타입의 버프가 있다면 새로운 것으로 교체)
                    simChar.pendingBuffs = simChar.pendingBuffs.filter(b => !(b.type === 'speed' && b.valueType === event.valueType));
                    simChar.pendingBuffs.push({
                        type: 'speed',
                        value: event.value,
                        valueType: event.valueType,
                        duration: event.buffDuration, // buffDuration 사용
                        turnsRemaining: event.buffDuration, // buffDuration 사용
                        appliedAtAv: event.appliedAtAv || 0, // 라운드 이벤트는 0
                        appliedThisTurnId: event.uiTurnId || null 
                    });
                }
            });
        }


        // 모든 캐릭터의 현재 속도를 버프에 따라 업데이트하는 함수
        function updateAllCharactersCurrentSpeed(simChars) {
            simChars.forEach(char => {
                let percentBuffSum = 0; // % 속도 버프의 합
                let fixedBuffSum = 0;   // 고정 속도 버프의 합

                char.buffs.forEach(buff => {
                    if (buff.type === 'speed') {
                        if (buff.valueType === '%') {
                            percentBuffSum += (buff.value / 100); // %를 소수점으로 변환
                        } else if (buff.valueType === 'fixed') {
                            fixedBuffSum += buff.value;
                        }
                    }
                });

                // 최종 속도 = 기본 속도 + (기본 속도 * % 버프 합) + 고정 버프 합
                // 여기서 initialCurrentSpeed를 사용해야 합니다. (baseSpeed * percentBuffSum) + fixedBuffSum는 합산된 속도를 나타냅니다.
                // 이전 턴에 속도 버프가 적용된 initialCurrentSpeed가 현재 속도의 기본값으로 작동합니다.
                let calculatedSpeed = char.initialCurrentSpeed + (char.baseSpeed * percentBuffSum) + fixedBuffSum;
                
                // 속도가 1 미만이 되지 않도록 보정하고, 소수점 반올림
                char.currentSpeed = Math.max(1, Math.round(calculatedSpeed)); 
            });
        }

        // 턴 이벤트 폼 보이기/숨기기
        function showTurnEventForm(formId, charId, currentAv, turnNum) { 
            // 다른 열려있는 모든 폼 닫기 (라운드 이벤트 폼 포함)
            document.querySelectorAll('.event-form').forEach(form => {
                form.classList.remove('active');
                if (form.parentNode && form.parentNode.classList.contains('round-event-form-wrapper')) {
                    form.parentNode.remove();
                }
            });

            const form = document.getElementById(formId);
            if (form) {
                form.classList.add('active'); // 폼 활성화

                // 폼 필드 초기화 및 값 설정
                const targetSelect = document.getElementById(`target-${formId.replace('form-','')}`); 
                targetSelect.innerHTML = `<option value="all">모든 캐릭터</option>` +
                    characters.map(c => `<option value="${c.id}">${c.name}</option>`).join(''); // 캐릭터 목록 옵션 채우기
                targetSelect.value = charId; // 현재 턴을 잡은 캐릭터가 기본 선택

                document.getElementById(`eventType-${formId.replace('form-','')}`).value = 'gauge';
                document.getElementById(`value-${formId.replace('form-','')}`).value = '';
                const buffDurationSelect = document.getElementById(`buffDuration-${formId.replace('form-','')}`);
                buffDurationSelect.innerHTML = BUFF_DURATION_OPTIONS.map(opt => `<option value="${opt.value}">${opt.label}</option>`).join('');
                buffDurationSelect.value = '0'; // 기본값 설정
                document.getElementById(`isHold-${formId.replace('form-','')}`).checked = false;

                toggleBuffDuration(formId); // 버프 지속 시간 필드 표시/숨김
            }
        }

        // 이벤트 종류에 따라 버프 지속 시간 필드 표시/숨김
        function toggleBuffDuration(formId) {
            const formElement = document.getElementById(formId);
            if (!formElement) return;

            const eventTypeSelect = formElement.querySelector('[id^="eventType-"]');
            const buffDurationGroup = formElement.querySelector('[id^="buffDurationGroup-"]');
            
            if (!eventTypeSelect || !buffDurationGroup) return; 

            if (eventTypeSelect.value === 'speed') {
                buffDurationGroup.style.display = 'block';
            } else {
                buffDurationGroup.style.display = 'none';
            }
        }

        // 턴 이벤트 적용 (futureEvents 배열에 저장)
        function applyTurnEvent(turnId, actingCharId, currentAv, turnNum) { 
            const targetId = document.getElementById(`target-${turnId}`).value;
            const eventType = document.getElementById(`eventType-${turnId}`).value;
            let valueInput = document.getElementById(`value-${turnId}`).value; 
            const isHold = document.getElementById(`isHold-${turnId}`).checked;
            const buffDuration = parseInt(document.getElementById(`buffDuration-${turnId}`).value);

            let value;
            let valueType = ''; 

            if (valueInput.endsWith('%')) {
                valueType = '%';
                value = parseFloat(valueInput.slice(0, -1)); 
            } else {
                valueType = 'fixed';
                value = parseFloat(valueInput); 
            }

            if (isNaN(value)) {
                alert('값을 올바르게 입력해주세요 (예: 20 또는 10%).');
                return;
            }

            const actingCharName = characters.find(c => c.id === actingCharId)?.name || '알 수 없는 캐릭터';
            const targets = targetId === 'all' ? characters : characters.filter(c => c.id === targetId);

            targets.forEach(targetCharOriginal => {
                let eventDescription = ``; 

                let eventData = {
                    type: 'turn', // 이벤트 타입 명시: 'turn' 또는 'round'
                    turnNum: turnNum, 
                    actingCharId: actingCharId, 
                    targetId: targetCharOriginal.id, 
                    eventType: eventType, // 'gauge' 또는 'speed'
                    value: value,
                    valueType: valueType, // '%' 또는 'fixed'
                    isHold: isHold,
                    buffDuration: buffDuration, // duration 대신 buffDuration으로 일관성 유지
                    appliedAtAv: currentAv, // 이벤트 발생 시점의 AV (UI에 표시용)
                    uiTurnId: turnId, // UI에 표시될 턴의 ID
                };

                if (eventType === 'gauge') {
                    eventDescription = `
                        ${actingCharName}이(가) ${targetCharOriginal.name}에게 행동 게이지 ${value}% 증가 
                        (AV: ${currentAv.toFixed(2)}, ${isHold ? '홀드 발동' : '턴 종료 후 발동'})
                    `;
                } else if (eventType === 'speed') {
                    eventDescription = `
                        ${actingCharName}이(가) ${targetCharOriginal.name}에게 속도 ${value}${valueType} 변동 
                        (${buffDuration > 0 ? buffDuration + '턴 지속' : '영구'}, AV: ${currentAv.toFixed(2)}, ${isHold ? '홀드 발동' : '턴 종료 후 발동'})
                    `;
                }
                eventData.description = eventDescription; // 이벤트 설명 추가
                
                futureEvents.push(eventData); // futureEvents 배열에 이벤트 추가
            });

            localStorage.setItem('futureEvents', JSON.stringify(futureEvents)); // 로컬 스토리지에 저장

            document.getElementById(`form-${turnId}`).classList.remove('active'); // 폼 숨기기
            runSimulation(); // 변경 사항 반영을 위해 시뮬레이션 다시 실행 (0턴부터)
        }

        // 페이지 로드 시 초기화 및 시뮬레이션 실행
        window.onload = () => {
            renderCharacterList(); // 캐릭터 목록 렌더링
            updateRoundToggleButtonUI(); // 라운드 표시 버튼 UI 업데이트
            loadDataFromUrl(); // URL에서 데이터 불러오기 시도
            runSimulation(); // 시뮬레이션 실행 (loadDataFromUrl이 완료된 후)
        };

    </script>
</body>
</html>
